import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:kafecraft_exam/model/exploitation.dart';
import 'package:kafecraft_exam/model/field.dart';
import 'package:kafecraft_exam/model/plant.dart';
import 'package:kafecraft_exam/provider/player_provider.dart';

final exploitationProvider =
    StateNotifierProvider<ExploitationProvider, Exploitation?>(
  (ref) => ExploitationProvider(ref),
);

class ExploitationProvider extends StateNotifier<Exploitation?> {
  final Ref ref;

  ExploitationProvider(this.ref) : super(null);

  Future<void> initialize() async {
    final player = ref.read(playerNotifier);
    if (player?.id != null) await loadExploitation(player!.id!);
  }

  Future<void> loadExploitation(String playerId) async {
    try {
      final snapshot = await FirebaseFirestore.instance
          .collection("exploitations")
          .where("playerId", isEqualTo: playerId)
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        state = Exploitation.fromMap(snapshot.docs.first.data())
            .copyWith(id: snapshot.docs.first.id);
      }
    } catch (e, stack) {
      print("Error loading exploitation: $e\n$stack");
      rethrow;
    }
  }

  Future<void> addExploitation(String name) async {
    final firestore = FirebaseFirestore.instance;
    final player = ref.read(playerNotifier);
    if (player == null) return;
    Exploitation exploitation = defaultExploitation(name, "Normal", player.id!);
    final docRef =
        await firestore.collection("exploitations").add(exploitation.toMap());
    state = exploitation.copyWith(id: docRef.id);
  }

  static Exploitation defaultExploitation(
      String name, String speciality, String playerId) {
    List<Field> fields = List.generate(4, (index) => Field(plants: []));
    return Exploitation(
      name: name,
      speciality: speciality,
      fields: fields,
      playerId: playerId,
    );
  }

  Future<void> updateFieldWithPlant(int fieldIndex, Plant plant) async {
    final firestore = FirebaseFirestore.instance;
    final player = ref.read(playerNotifier);

    if (player == null || state == null) return;

    try {
      List<Field> updatedFields = List.from(state!.fields);
      updatedFields[fieldIndex] = updatedFields[fieldIndex].copyWith(
        plants: [...updatedFields[fieldIndex].plants, plant],
      );

      await firestore.collection("exploitations").doc(state!.id).update({
        'fields': updatedFields.map((field) => field.toMap()).toList(),
      });

      state = state!.copyWith(fields: updatedFields);
    } catch (e) {
      print("Erreur lors de la mise à jour du champ avec la plante: $e");
    }
  }

  Future<void> removePlant(int fieldIndex) async {
    final firestore = FirebaseFirestore.instance;
    final player = ref.read(playerNotifier);

    if (player == null || state == null) return;

    try {
      List<Field> updatedFields = List.from(state!.fields);
      updatedFields[fieldIndex] =
          updatedFields[fieldIndex].copyWith(plants: []);

      await firestore.collection("exploitations").doc(state!.id).update({
        'fields': updatedFields.map((field) => field.toMap()).toList(),
      });

      state = state!.copyWith(fields: updatedFields);
    } catch (e) {
      print("Erreur lors de la récolte: $e");
    }
  }
}
